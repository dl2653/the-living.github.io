---
layout:     post
title:      Fluid Dynamics in Generative Design for Architecture
date:		2017-01-30
author:     Damon
summary:    Use CFD to quantify air flow and thermal properties of a building in a generative workflow.
image:		cfd_title.JPG
tags:
- Simulation
- Generative Geometry
- CDF
- Optimization

---
 
A generative design system for architecture would be incomplete without analysis of fluid dynamics. CFD can be used to study exterior air flows, passive ventilation, and micro climates on building envelopes. On the interior, the same simulation engine can determine HVAC air flow, interior convection currents, thermal conductivity, and the summary metric, human comfort index. 

### Methodology
Through the Toronto MaRS project, The Living established a robust method for simulating and analyzing building designs for 6 comprehensive metrics including daylight, visual distraction, views, adjacency, workstyle, and buzz. We can add fluid dynamics and the many quantifiable design qualities which can be derived from CFD to our simulation toolbox with an automated link between Autodesk Simulation CFD, geometry generation, and results analysis via SimCFD's included Python API and o2's plugin system. 


### Design Implications
- A designer can create spaces with immediate CFD feedback using the same ubiquitous tools commonly used for design exploration.
- Balance trade offs between air flow and other dependant metrics such as daylight, distraction, views, etc. 
- Typically air flow is handled in separate phases of a project between designer and mechanical engineers. More of the fluid dynamics and thermal considerations can be considered at an earlier phase.
- Time consuming processes of simulation setup and post processing can be handled in an automated script.

### Example Projects

### Simulation Use Cases
**General Purpose Wind Tunnel Workflow:** For models analyzing exterior air flow, we can create a bounding box geometry with a wind velocity or fan at one end and a static pressure at the opposite end with a target geometry in the middle to analyze. This has the benefit of being able to setup the simulation model with the bounding volume and conditions before hand, and the automation process only modifies the interior target geometry. 

![image](/images/SimCFD_setup.png)

fig 1.above: Wind Tunnel setup with 1m square fixed volume and interchangable targets (sample file here)

**Building Specific Model:** For more specific requirements using unique interior spaces, we need to define the air volume and materials in separate steps. The base STP file includes metadata such as object name and layer, which the SimCFD interface can identify and use to assign materials or object type such as fan, heatsink, roatating region, valve, etc. On an interior model we can also run a thermal analysis and use SimCFD's Design Study Environment to compare the same design in multiple scenarios ie. winter vs summer.  

![image](/images/SimCFD_setup_mars.png)
 
fig 2.above: Interior space analysis of Toronto MaRS building model (sample file here)

**Detailed Part Analysis** After an automated run, in many cases it would be necessary to zoom into greater detail on the model and plot figures along the surface of the model. 

![image](/images/princeton_bd.png)

fig 3.above: Princeton sandblasted scaffold board detailed analaysis (sample file here)


### Geometry Creation and Automation
There are a few options for bridging geometry generation processes with SimCFD. Perhaps the simplest is through the command line interface which takes two arguments, the SimCFD install path and the base python script. It is also possible to manually create a base file, and update the geometry via the provided API tools in the UI. For our purposes, the former method is useful because both the geometry generation and analysis can be done with no UI inputs. SimCFD has a headless (no GUI) mode which can be accessed through the Windows command line and the python API.  


In order for python to call the SimCFD API, the following headder must be added to the script. Most functions rely on the modules DesignStudy, ActiveScenario, and Results. This corresponds with the SimCFD interface for Setup, which simulation conditions are created; DSE, where designs are compared; and Results, where the detailed analysis can be reviewed. 

```python
from CFD import Setup
from CFD import DSE
from CFD import DC
from CFD import Results

study = Setup.DesignStudy.Create()
study.open(cfd_file) 
scenario = study.getActiveScenario()
design = study.design( "Design 1" )

#if results exist, include following:
results = scenario.results()

```


To launch SimCFD with the script in the headless (no GUI) mode, the following function can be used to launch one or multiple designs. 

```python
# Use with Mars GD with 1 input parameter

def cfd_run_single(cfdst_path, sim_path, stp_path, seed_input):

    with open("seed.txt", "w") as f: # input file for geometry generation
        f.write( seed_input )
    
    with open('source.csv', "w") as f1: # input file for base sim file
        f1.write(str("{},{},{},{}".format(cfdst_path, sim_path, stp_path, seed_input) ) ) 

    # launch first CFD task - geometry update, materials, environment
    cmd_command = "{} -script {}".format(cfd_exe, "windy_pidgy.py")
    os.system(cmd_command)

    # launch second CFD task - visualize model with flow lines and summary plane
    cmd_command_2 = "{} -script {}".format(cfd_exe, "viz.py") 
    os.system(cmd_command_2)

```

### Simulation

**Setup:**


**Analysis:**


**Turbelance models:** k-epsilon, SST k-omega, Scale Adaptive Simulation (SST k-omega SAS)

### Results

In order to extract results from the model, we need to either create a monitor point or a summary plane. The monitor point probes the analysis results at a specific 3D point while the summary plane takes values from a 2D plane. 

```python
#Create summary plane and extract results

cp1 = Results.CutPlane.Create(results, "Plane 1") # create cut plane
cp1.setLocation(0.25,0.25,0.6) # set location of cut plane
cp1.setNormal(0,0,1) # set the orientation of cut plane

sp1 = DC.SummaryPlane.Create(study.decisionCenter(), cp1) # convert cut plane to summary plane

min, curr, max = 0.0, 0.0, 0.0 
err, min, curr, max = cp1.getGridSpacingValues(min, curr, max)
DSE.UI.ShowMessage( "\tmin = %g   curr = %g   max = %g" % (min, curr, max) ) # general general summary values
  
summary_data = []

sp_results = DC.SummaryItemResults() # get detailed results from SP
sp1.getResults( sp_results )

for resultType, design in sp_results.iteritems():
    for designName, scenario in design.iteritems():
        for scenarioName, val in scenario.iteritems():
            resultStr = DC.SummaryPlane.ResultTypeToString(resultType)
            name = designName + "::" + scenarioName
            val = resultStr + "=" + str(val)
            val = str(val)
            DSE.UI.ShowMessage(val)
    summary_data.append(val)

summary_data = str(summary_data)[1:-1]
print("\n\n\n SUMMARY DATA: ",summary_data,"\n\n\n")

```


### Next Steps

Connect with FEA Solver and broader optimization objectives. 
### Simulation

**Setup:**


**Analysis:**


**Turbelance models:** k-epsilon, SST k-omega, Scale Adaptive Simulation (SST k-omega SAS)

### Results

In order to extract results from the model, we need to either create a monitor point or a summary plane. The monitor point probes the analysis results at a specific 3D point while the summary plane takes values from a 2D plane. 

```python
#Create summary plane and extract results

cp1 = Results.CutPlane.Create(results, "Plane 1") # create cut plane
cp1.setLocation(0.25,0.25,0.6) # set location of cut plane
cp1.setNormal(0,0,1) # set the orientation of cut plane

sp1 = DC.SummaryPlane.Create(study.decisionCenter(), cp1) # convert cut plane to summary plane

min, curr, max = 0.0, 0.0, 0.0 
err, min, curr, max = cp1.getGridSpacingValues(min, curr, max)
DSE.UI.ShowMessage( "\tmin = %g   curr = %g   max = %g" % (min, curr, max) ) # general general summary values
  
summary_data = []

sp_results = DC.SummaryItemResults() # get detailed results from SP
sp1.getResults( sp_results )

for resultType, design in sp_results.iteritems():
    for designName, scenario in design.iteritems():
        for scenarioName, val in scenario.iteritems():
            resultStr = DC.SummaryPlane.ResultTypeToString(resultType)
            name = designName + "::" + scenarioName
            val = resultStr + "=" + str(val)
            val = str(val)
            DSE.UI.ShowMessage(val)
    summary_data.append(val)

summary_data = str(summary_data)[1:-1]
print("\n\n\n SUMMARY DATA: ",summary_data,"\n\n\n")

```


### Next Steps

Connect with FEA Solver and broader optimization objectives. 
